
==================== Tidy Core ====================

Result size of Tidy Core
  = {terms: 147, types: 426, coercions: 148, joins: 0/1}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 = "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 = "Main"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule = Module $trModule3 $trModule1

Rec {
-- RHS size: {terms: 32, types: 34, coercions: 38, joins: 0/1}
$wgo
  = \ ww_sd6s @r1_sd6l w_sd6n w1_sd6p w2_sd6q ->
      case ># ww_sd6s 100000# of {
        __DEFAULT ->
          ((w_sd6n
              (I# ww_sd6s)
              (let { w3_sd6I = +# ww_sd6s 1# } in
               (\ @r2_X6 _ w5_X7 _ w7_X8 w8_X9 -> $wgo w3_sd6I w5_X7 w7_X8 w8_X9)
               `cast` <Co:34>))
           `cast` <Co:2>)
            w2_sd6q;
        1# -> (w1_sd6p `cast` <Co:2>) w2_sd6q
      }
end Rec }

-- RHS size: {terms: 4, types: 17, coercions: 0, joins: 0/0}
main2 = \ s_acov -> (# s_acov, Stop #)

-- RHS size: {terms: 6, types: 17, coercions: 0, joins: 0/0}
lvl5_rd8O = \ @r_ibPR _ _ _ stp_ibPV -> stp_ibPV

-- RHS size: {terms: 7, types: 18, coercions: 4, joins: 0/0}
lvl6_rd8P
  = \ a1_ibPQ s_acov ->
      (# s_acov, Yield a1_ibPQ (lvl5_rd8O `cast` <Co:4>) #)

-- RHS size: {terms: 8, types: 21, coercions: 0, joins: 0/0}
main3
  = \ a1_ibPO x_ibPP s_acov -> (# s_acov, Yield a1_ibPO x_ibPP #)

Rec {
-- RHS size: {terms: 32, types: 55, coercions: 41, joins: 0/0}
main_$sgo1
  = \ sc_sd76 sc1_sd77 eta_X4 ->
      case (((sc_sd76 `cast` <Co:3>)
               adaptState1
               (main3 `cast` <Co:15>)
               (lvl6_rd8P `cast` <Co:10>)
               (main2 `cast` <Co:7>))
            `cast` <Co:6>)
             eta_X4
      of
      { (# ipv_a4uY, ipv1_a4uZ #) ->
      case ipv1_a4uZ of {
        Yield x_id3s s2_id3t ->
          case x_id3s of { I# y_a9DA ->
          main_$sgo1 s2_id3t (+# sc1_sd77 y_a9DA) ipv_a4uY
          };
        Skip s2_id3D -> main_$sgo1 s2_id3D sc1_sd77 ipv_a4uY;
        Stop -> (# ipv_a4uY, () #)
      }
      }
end Rec }

-- RHS size: {terms: 28, types: 84, coercions: 22, joins: 0/0}
main_$sgo
  = \ sg_sd70 eta_X4 ->
      case $wgo 0# (main3 `cast` <Co:15>) (main2 `cast` <Co:7>) eta_X4 of
      { (# ipv_a4uY, ipv1_a4uZ #) ->
      case ipv1_a4uZ of {
        Yield x_id3s s2_id3t ->
          case x_id3s of { I# y_a9DA -> main_$sgo1 s2_id3t y_a9DA ipv_a4uY };
        Skip s2_id3D -> main_$sgo1 s2_id3D 0# ipv_a4uY;
        Stop -> (# ipv_a4uY, () #)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 34, joins: 0/0}
main1 = main_$sgo @~<Co:34>

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
main = main1 `cast` <Co:3>

-- RHS size: {terms: 2, types: 1, coercions: 3, joins: 0/0}
main4 = runMainIO1 (main1 `cast` <Co:3>)

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
main = main4 `cast` <Co:3>


------ Local rules for imported ids --------
"SPEC/Main fromStreamK @IO _" [0]
    forall @a_X1F $dMonad_sd3O.
      fromStreamK $dMonad_sd3O
      = \ eta_ibPL ->
          UnStream
            (\ gst_ibPM m1_ibPN ->
               (m1_ibPN `cast` <Co:3>)
                 gst_ibPM
                 ((\ a1_X1G x_X1H s_X1I -> (# s_X1I, Yield a1_X1G x_X1H #))
                  `cast` <Co:15>)
                 ((\ a1_X1G s_X1H ->
                     (# s_X1H,
                        Yield
                          a1_X1G ((\ @r_ibPR _ _ _ stp_ibPV -> stp_ibPV) `cast` <Co:4>) #))
                  `cast` <Co:10>)
                 ((\ s_X1G -> (# s_X1G, Stop #)) `cast` <Co:7>))
            eta_ibPL
"SPEC/Main unfoldrMSerial @IO _ _" [2]
    forall @b_ico5 @a_ico6 $dMonadIO_sd3W.
      unfoldrMSerial $dMonadIO_sd3W
      = (\ eta_ico8
           eta1_ico9
           @r_icoa
           eta2_icob
           eta3_icoc
           eta4_icod
           eta5_icoe ->
           ((toStreamK $fMonadIO (unfoldrM $fMonadIO eta_ico8 eta1_ico9))
            `cast` <Co:3>)
             eta2_icob eta3_icoc eta4_icod eta5_icoe)
        `cast` <Co:15>
"SPEC/Main drain @Stream @IO _" [2]
    forall @a_icmJ $dIsStream_sd45 $dMonad_sd46.
      drain $dIsStream_sd45 $dMonad_sd46
      = \ m1_icmM -> drain $fMonadIO (fromStreamK $fMonadIO m1_icmM)

